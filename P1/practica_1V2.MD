# Pr√°ctica 1: Blink con ESP32

---

## üéØ Objetivo

El objetivo de esta pr√°ctica es generar el parpadeo peri√≥dico de un LED utilizando un ESP32. Adem√°s, se emplea la salida serie para depuraci√≥n y se comparan distintas t√©cnicas: funciones est√°ndar de Arduino, acceso directo a registros, y distintas formas de temporizaci√≥n. Finalmente, se analiza el rendimiento del microcontrolador.

---

## ‚öôÔ∏è Microcontrolador: ESP32

### Imagen del ESP32

![ESP32](https://ae04.alicdn.com/kf/S8dee2f4cafc344e1b57ebc21ad5c11a4P.jpg?fit=600%2C600&ssl=1)

### Distribuci√≥n de pines

![Pines ESP32](https://ae04.alicdn.com/kf/S61a9f7eb6ad3487ca95acc2f410157a35.jpg?resize=966%2C574&ssl=1)

---

## üîß Descripci√≥n de la funcionalidad

- Iniciar pin de LED como salida
- Bucle infinito:
  - Encender LED
  - Enviar mensaje "ON" por el puerto serie
  - Esperar 500 o 1000 ms
  - Apagar LED
  - Enviar mensaje "OFF" por el puerto serie
  - Esperar 500 o 1000 ms# PRACTICA 1  :  BLINK

El objeticvo de la practica es producir el parpadeo periodico de un led. 
Se utilizara la salida serie  para depurar  el programa 

El microcontrolador que utilizaremos es el ya comentado en la introducci√≥n  **ESP32**


---

## üß™ Implementaciones

### üü¢ 1. C√≥digo b√°sico

```cpp
#define LED_BUILTIN 2
#define DELAY 500

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  digitalWrite(LED_BUILTIN, HIGH);
  delay(DELAY);
  digitalWrite(LED_BUILTIN, LOW);
  delay(DELAY);
}


### üü¢ 2 Codigo con salida serie

#define LED_BUILTIN 2
#define DELAY_TIME 1000

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  digitalWrite(LED_BUILTIN, HIGH);
  Serial.println("ON");
  delay(DELAY_TIME);

  digitalWrite(LED_BUILTIN, LOW);
  Serial.println("OFF");
  delay(DELAY_TIME);
}

#define LED_PIN 2

void setup() {
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  GPIO.out_w1ts = (1 << LED_PIN);
  Serial.println("ON");

  unsigned long startMillis = millis();
  while (millis() - startMillis < 500);

  GPIO.out_w1tc = (1 << LED_PIN);
  Serial.println("OFF");

  startMillis = millis();
  while (millis() - startMillis < 500);
}

![Foto de Ruben Garcia](https://github.com/ruben22garcia/PD_2025/blob/main/P1/Practica1/IMG_748E83AF-4ED5-4C90-9EE6-65B3522506C6.JPEG)


### üü¢ 3. Acceso directo a registros + espera activa

#define LED_PIN 2

void setup() {
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  GPIO.out_w1ts = (1 << LED_PIN);
  Serial.println("ON");

  unsigned long startMillis = millis();
  while (millis() - startMillis < 500);

  GPIO.out_w1tc = (1 << LED_PIN);
  Serial.println("OFF");

  startMillis = millis();
  while (millis() - startMillis < 500);
}


### üü¢ 4. Alternativas para medir frecuencia


#define LED_PIN 2

void setup() {
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  digitalWrite(LED_PIN, HIGH);
  Serial.println("ON");

  while(millis() % 2 == 0);

  digitalWrite(LED_PIN, LOW);
  Serial.println("OFF");

  while(millis() % 2 == 1);
}

## üü¢ Diagrama de flujo

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    setup()   ‚îÇ
‚îÇ - pinMode    ‚îÇ
‚îÇ - Serial.begin ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ   loop()  ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Encender LED‚îÇ
‚îÇ Serial "ON" ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Esperar     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Apagar LED  ‚îÇ
‚îÇ Serial "OFF"‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Esperar     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
      (loop)



üß† Tiempo libre del procesador

Durante las esperas activas (delay() o while()), el procesador no ejecuta otras tareas, pero tampoco realiza trabajo √∫til (bloqueo activo). Esto significa que:

    Ocupado √∫til: solo unos pocos microsegundos por ciclo.

    Tiempo "libre" (esperando): ~99.9% del tiempo.

‚úÖ Conclusiones

    El uso de registros es m√°s eficiente y permite alcanzar frecuencias m√°s altas.

    El uso de funciones Arduino es m√°s legible, pero introduce latencias y es menos preciso.

    La espera activa con millis() permite mantener el control sin usar delay(), pero consume CPU.

    El puerto serie reduce significativamente la frecuencia m√°xima de parpadeo.

    El ESP32 tiene una alta capacidad de respuesta cuando no se bloquea con delay() o Serial.
